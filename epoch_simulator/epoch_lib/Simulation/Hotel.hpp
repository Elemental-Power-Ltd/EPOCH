#pragma once

#include <Eigen/Core>
#include <Eigen/Dense>

#include "TaskComponents.hpp"
#include "SiteData.hpp"
#include "../Definitions.hpp"

class Hotel {

public:
    Hotel(const SiteData& siteData, const Building& buildingData) :
        mTimesteps(siteData.timesteps),	// Used in init & functions
        // Initilaise data vectors with all values to zero
        mTargetLoad_e(siteData.building_eload * buildingData.scalar_electrical_load),
        mTargetDHW_h(siteData.dhw_demand)

        //TargetPool_h(Eigen::VectorXf::Zero(BattData.TS_max))
    {
        if (buildingData.fabric_intervention_index == 0) {
            mTargetHeat_h = siteData.building_hload * buildingData.scalar_heat_load;
        }
        else {
            // we subtract 1 as fabric_intervention_index effectively uses 1-based indexing
            // because 0 corresponds to the default building_hload
            auto& scenarioIntervention = siteData.fabric_interventions[buildingData.fabric_intervention_index - 1];
            mTargetHeat_h = scenarioIntervention.reduced_hload * buildingData.scalar_heat_load;
        }
    }

    void AllCalcs(TempSum& tempSum) {
        // Apply demands generated by the hotel to the tempSum values
        tempSum.Heat_h += mTargetHeat_h;
        tempSum.DHW_load_h += mTargetDHW_h;

        tempSum.Elec_e += mTargetLoad_e;
    }


    void Report(ReportData& reportData) {
        // report target load to allow calculation of revenue missed
        reportData.Hotel_load = mTargetLoad_e;
        reportData.CH_demand = mTargetHeat_h;
        reportData.DHW_demand = mTargetDHW_h;
        reportData.Heatload = mTargetHeat_h + mTargetDHW_h;
    }

private:
    const size_t mTimesteps;

    year_TS mTargetLoad_e;
    year_TS mTargetDHW_h;
    year_TS mTargetHeat_h;
    //year_TS TargetPool_h;
};