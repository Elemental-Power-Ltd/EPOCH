import itertools

import matplotlib.patheffects as path_effects
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.axes import Axes

from app.models.core import PortfolioOptimisationResult

from .tree_construction import find_maximising_path, is_in_elec_shortfall, is_in_heat_shortfall


def draw_upgrade_tree(
    all_results: dict[str, PortfolioOptimisationResult],
    G: nx.Graph[str],
    source: str,
    sink: str,
    possible_components: list[str],
    node_size: int = 400,
    font_size: int = 12,
    ax: Axes | None = None,
) -> Axes:
    """
    Draw an upgrade tree.

    This upgrade tree can be generated by the code in `tree_construction` and should be a directed graph.
    We'll draw a green path from source to sink that maximises payback.

    Parameters
    ----------
    all_results
        Portfolio results that we can get metrics from
    G
        Graph to draw
    source
        First node, probably the one at the bottom of the tree
    sink
        Last node, probably the one at the top of the tree
    possible_components
        Human readable names of the components to add into labels
    node_size
        Size of each node in px
    font_size
        Size of the labels on each node
    ax
        Axes to draw on; make new ones if not provided

    Returns
    -------
    Axes
        Nicely drawn upgrade tree
    """
    heat_thresh = 150
    shortfall_nodes = [key for key in all_results.keys() if is_in_elec_shortfall(key, all_results, 0.0)]
    heat_shortfall_nodes = [key for key in all_results.keys() if is_in_heat_shortfall(key, all_results, heat_thresh)]

    shortest_path = find_maximising_path(G, source, sink, weight="operating_cost", sign=1)
    shortest_path_components = [{possible_components[idx] for idx, val in enumerate(s) if val == "1"} for s in shortest_path]
    order = [(y - x).pop() for x, y in itertools.pairwise(shortest_path_components)]

    if ax is None:
        _, ax = plt.subplots()
    pos = nx.get_node_attributes(G, "pos")
    labels = nx.get_node_attributes(G, "label")
    in_cost_nodes = list(G.nodes)
    nx.draw_networkx_nodes(G, pos=pos, node_size=node_size, nodelist=in_cost_nodes, ax=ax)
    nx.draw_networkx_nodes(G, pos=pos, node_size=node_size, nodelist=shortfall_nodes, node_color="#DD0000", ax=ax)
    nx.draw_networkx_nodes(G, pos=pos, node_size=node_size, nodelist=heat_shortfall_nodes, node_color="#DDA600", ax=ax)
    nx.draw_networkx_edges(G, pos=pos, node_size=node_size, arrows=False, ax=ax)
    label_text = nx.draw_networkx_labels(G, pos=pos, labels=labels, font_size=font_size, ax=ax, font_color="white")
    for text in label_text.values():
        text.set_path_effects([path_effects.Stroke(linewidth=3, foreground="black"), path_effects.Normal()])
    nx.draw_networkx_edges(
        G, pos=pos, node_size=node_size, edgelist=list(itertools.pairwise(shortest_path)), edge_color="green", width=4.0, ax=ax
    )
    nx.draw_networkx_edge_labels(
        G, pos=pos, edge_labels={k: f"£{v:.2f}" for k, v in nx.get_edge_attributes(G, "operating_cost").items()}, font_size=8
    )
    operating_costs = nx.get_node_attributes(G, "operating_cost")
    ax.set_title(" -> ".join(order) + "\n" + f"Operating cost: £{operating_costs[sink]:.2f}")
    min_x, max_x = min(item[0] for item in pos.values()) * 1.1, max(item[0] for item in pos.values()) * 1.1

    ax.set_xlim(min_x * 1.2, max_x * 1.4)
    ax.set_ylim(min(item[1] - 2 for item in pos.values()), max(item[1] + 2 for item in pos.values()))
    return ax
